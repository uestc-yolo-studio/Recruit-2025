# 后端方向考核题

## 提交地址

@宋雨朋 3071372442@qq.com
@冯云浩 1662952770@qq.com

## 提交方式

请你先建一个文件夹来保存你做题的答案，文件名字你喜欢就行，然后在这个文件夹下再建一个文件夹assets，这个文件夹用来保存你的代码运行截图或者其他图片，请你每一个部分写一个markdown文档，markdown文档中的图片一律使用相对路径也就是类似于`assets\23134asd.png` 这样的路径

文件夹的结构类似于这样:

然后提交时打包为`.zip` 文件，然后以`学号-姓名-方向-部分` 的形式提交，示例`202309091565-小明-后端-JAVA基础` 。

文档不应该仅仅包含你的做题答案，还应该包含你做题时遇到的问题和解决的方式，我们更希望看到你的学习过程。

## 简介

欢迎各位24级的各位同学点开YOLO工作室后端招新题，进入奇妙的Java世界。在这篇文档中我们将试图为你的Java学习做一些引导。加入工作室之后，更是有詹少😊雷神🤪郭神😍这种位面顶级大能为你提供Java指导，带你手撕面试，剑指offer！

Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程

本次题目包括JAVA基础、对象、数据结构、数据库、系统设计五个部分。标记有选做的部分可以学有余力再行尝试。如果对题目有什么疑问，或者需要一些引导，可以私戳本部分的出题人（在标题处可以看到）。

尽管我们在文末贴出了相关的一些学习资料，但是也请你不要将眼光局限于这些资料。善用搜索引擎，在网络上高效地检索信息是程序员的必备技能！

招新题完成数量不设指标，只要我们能从中看出你的学习能力、学习态度，你就有可能被选中,加入光荣的进化YOLO工作室！

## 做题前的准备

1. 安装JDK，配置环境变量。
2. 安装IntelliJ IDEA（推荐）或 Eclipse。 记事本也不是不行 
3. 学会markdown语法来编写你的文档，推荐使用typora。
4. 我们鼓励你用gpt来进行学习，但是我们更希望你能用自己的理解来做每一道题。

## 欢迎来到代码魔法师的史诗试炼：构建你的宠物数字世界！

你好，勇敢的挑战者！

你并非只是在参与一场普通的招新考核，而是即将踏上一段作为“代码魔法师”的传奇旅程。在这个世界里，你手中的Java代码便是驱动万物的魔法。你的使命，是从一片混沌开始，亲手构建一个充满生机与奇迹的“宠物数字世界”。

这不仅是一场对你技术实力的深度考验，更是一次创造力与想象力的冒险。你将从学习最基础的“创世咒语”（Java基础）开始，到运用“生命魔法”（数据结构）创造生灵，再通过“灵魂注入”（面向对象）赋予它们独特的个性和行为。随后，你将为这个世界“建立秩序”（数据库），并最终以一位真正的“世界架构师”的身份，建成宏伟的“宠物领养中心”（系统设计）。

准备好了吗？握紧你的魔杖（键盘），念出第一句咒语，让我们开始这场激动人心的创世之旅！

### 章节一：魔法入门 —— 学习创世的基本规则

> 欢迎来到魔法学院的初级课堂。任何伟大的魔法师，都始于对世界底层规则的深刻理解。在本章，你将学习驱动这个数字世界运转的最核心、最基础的魔法原理。它们如同物理定律，是构建一切上层建筑的基石。请仔细研读，这将是你未来施展高等魔法的关键。

#### 1.1 创世咒语：Java的编译与运行魔法

> 每一句Java代码，都是一句蕴含力量的咒语。但咒语本身并不能直接撼动世界，它需要通过特定的仪式（编译）转换成能被“世界核心”（JVM）所理解的魔力形态（字节码）。

**你的第一个挑战：揭示咒语生效的秘密**

1. **魔法的两种流派**：世间的编程语言分为“编译型”与“解释型”两大流派。请探索：
  1. 这两种流派的定义是什么？它们各自的施法仪式（运行流程）有何不同？
  2. Java属于哪一流派？它为何能兼具两者的特性，实现“一次编译，到处运行”的跨平台魔法？
  3. 在Java的魔法体系中，JVM（Java虚拟机）和JIT（即时编译器）分别扮演着怎样的角色？它们是如何协同工作，让你的咒语高效运行的？
2. **描绘你的魔法阵**：根据你的理解，绘制一幅完整的Java程序编译与执行流程图。这将是你理解整个魔法体系的基石。
3. **语言的本质**：
  1. Java是“静态语言”还是“动态语言”？与灵活多变的Python相比，它在类型系统上有何异同？
  2. 作为一门“强类型静态语言”，Java是否也隐藏着某些“动态”的魔法潜能？
  3. 与Python相比，Java严格的类型系统（类型魔法）带来了哪些优势，又存在哪些局限？

#### 1.2 魔力指针：理解“引用”的奥秘

> 在这个世界中，你创造的所有事物（对象）都安放在一个名为“内存”的异次元空间。你无法直接触碰它们，只能通过一种名为“引用”的魔力指针来间接操控。理解引用的本质，是成为高级魔法师的关键一步。

**你的第二个挑战：掌握操控万物的魔力指针**

1. **探寻指针的踪迹**：
  1. 你可能听说过C语言中那把锋利无比的“指针”之剑。在Java的魔法世界里，是否存在同样的东西？
  2. Java中的“引用”究竟是什么？与指针相比，这种设计为我们的世界带来了什么（例如，安全性和简便性）？
  3. 一个经典的魔法辩题：Java中的参数传递，究竟是“值传递”还是“引用传递”？请阐述你的观点。
2. **引用的四重形态**：Java中的引用并非铁板一块，它有四种不同的强度等级（强、软、弱、虚）。
  1. 请探究这四种引用形态的特性，以及它们在何种情况下会自动断开与对象的连接。
  2. 它们各自适用于哪些特殊的魔法场景？（例如：构建缓存、监控对象回收）
3. **实践中的洞察**：Java世界为了安全，不允许魔法师直接操作内存地址。我们的一切操作都是通过“引用”这根魔杖完成的。请思考：为何Java要采用这种模式？
  1.  接下来，请在不运行下方代码的情况下，预测它的输出，并从Java内存模型（尤其是字符串常量池和栈、堆的交互）的角度，详细解释你的答案。

  2. ```Java
      public class StringTest {
          public static void main(String[] args) {
              String str = "hello";
              change(str);
              System.out.println(str);
          }
      
          public static void change(String s) {
              s = s + " world";
          }
      }
      ```

> 恭喜你，魔法师！你已掌握了创世的基础规则。但这片虚空还是一片沉寂，是时候运用更精妙的“生命魔法”——数据结构，为这个世界创造第一批生灵了。它们是构成世界的基本元素，是未来一切复杂生命形态的起源。

### 章节二：创造生灵 —— 用数据结构塑造世界

> 恭喜你，魔法师！你已掌握了创世的基础规则。但这片虚空还是一片沉寂，是时候运用更精妙的“生命魔法”——数据结构，为这个世界创造第一批生灵了。它们是构成世界的基本元素，是未来一切复杂生命形态的起源。

#### 2.1 第一关：塑造生命的基本形态——链接核心 (MyLinkedList)

> 在这个世界里，最古老的生命形态是一种由节点链接而成的流光。它们灵活、可变，是构成更复杂生物的基础。这，就是“链表”。

**挑战任务：从零开始，打造你的第一个链式生灵**

1. **理解生命形态**：首先，请简要阐述“链表”这种生命形态的本质，并与静态的“数组”进行对比，说明其独特的优势（如动态伸缩）。
2. **铸造链接核心**：现在，请你亲手实现一个名为 `MyLinkedList` 的自定义单向链表类。你需要为它赋予以下核心能力：
  1. `void add(int value)`: 在生命的末端追加一个新的光点（节点）。
  2. `void insert(int index, int value)`: 在指定位置（索引）精准植入一个新的光点。
  3. `int get(int index)`: 读取并返回指定位置光点的能量值（value）。
  4. `void remove(int index)`: 熄灭并移除指定位置的光点。
  5. `int size()`: 感知并返回当前生命形态包含的光点总数。
3. **生命测试**：为你的 `MyLinkedList` 编写测试魔法，确保它的每一项能力都如你预期般精确无误。

**进阶挑战：赋予生命逆转时空的能力**

- 实现一个 `reverse()` 方法，让你的链式生灵能够瞬间反转自身结构。请简要阐述你实现这一高级魔法的思路。
  -  **原始形态:**`head → [1] → [2] → [3] → null`

  -  **施法逆转后:**`head → [3] → [2] → [1] → null`

#### 2.2 第二关：定义生命的流动与呼吸——栈与队列的魔法

> 世界诞生了最基础的形态，但还需要规则来引导能量的流动。接下来，你将学习两种基础的能量流动模式：“栈”——后进先出的能量井，以及“队列”——先进先出的能量通道。它们是系统呼吸与思考的基础。

**挑战任务A：构建****后进先出****的能量井 (MyStack)**

- **核心要求**：基于数组或链表（可使用Java内置的`LinkedList`），构建一个自定义的栈 `MyStack`。
- **必须实现的魔法接口**：
  - `void push(int value)`: 将能量压入井中。
  - `int pop()`: 从井口弹出一个能量单位。
  - `int peek()`: 查看井口的能量，但不取出。
  - `boolean isEmpty()`: 感知能量井是否枯竭。

**挑战任务B：构建先进先出的能量通道 (MyQueue)**

- **核心要求**：基于链表（可使用Java内置的`LinkedList`）实现一个自定义队列 `MyQueue`。
- **必须实现的魔法接口**：
  - `void enqueue(int value)`: 能量从通道一端进入。
  - `int dequeue()`: 能量从另一端流出。
  - `int peek()`: 查看即将流出的能量形态。
  - `boolean isEmpty()`: 感知通道是否为空。

**智慧拓展：魔法的变通与溯源**

- **魔法互换**：思考一下，你能否只用“能量井”（栈）来模拟出“能量通道”（队列）的效果？反之，用“能量通道”能否模拟“能量井”？请阐述你的思路，无需编码。
- **追本溯源**：在Java的官方魔法库中，是否存在现成的“栈”与“队列”实现？若有，它们是如何构建的？与你亲手打造的相比，有何异同与优劣？

#### 2.3 第三关：构建生命的智慧核心——二叉树的奥秘

> 单纯的线性生命太过简单，是时候创造拥有初步智慧的生物了。你将构建一种名为“二叉树”的结构，它拥有分叉的“思维路径”，是未来构建复杂决策系统的基础。

**挑战任务：激活二叉树的思维脉络**

1. **理解智慧结构**：请简要说明“二叉树”这种数据结构的核心特点。
2. **思维遍历**：对于一个给定的二叉树，魔法师有三种主要的探知其内部结构的方式：前序、中序和后序遍历。请你使用“递归”这一优雅的魔法，实现这三种遍历方式，并揭示树中所有节点的秘密。
  1. ```Java
      // 树节点的定义
      class TreeNode {  
          int val; // 节点蕴含的能量值
          TreeNode left, right; // 指向左右两个思维分支的引用
          TreeNode(int val) { this.val = val; }
      }
      
      public class BinaryTreeTraversal {
      
          // 构建一个样本智慧核心
          public static TreeNode buildSampleTree() { ... }
      
          // 前序遍历（核心 -> 左分支 -> 右分支）
          public static void preorder(TreeNode node) { /* 你的魔法代码 */ }
          // 中序遍历（左分支 -> 核心 -> 右分支）
          public static void inorder(TreeNode node) { /* 你的魔法代码 */ }
          // 后序遍历（左分支 -> 右分支 -> 核心）
          public static void postorder(TreeNode node) { /* 你的魔法代码 */ }
      
          // 魔法测试
          public static void main(String[] args) {
              TreeNode root = buildSampleTree();
              System.out.print("前序探知：");
              preorder(root); // 预期输出: 1 2 4 5 3 6
              System.out.println();
      
              System.out.print("中序探知：");
              inorder(root); // 预期输出: 4 2 5 1 3 6
              System.out.println();
      
              System.out.print("后序探知：");
              postorder(root); // 预期输出: 4 5 2 6 3 1
          }
      }
      ```

### 章节三：赋予灵魂 —— 面向对象的魔法艺术

> 你创造的生灵拥有了形态和智慧，但它们仍然是冰冷的、没有个性的。现在，你将进入一个更高的魔法领域：面向对象编程。在这里，你将学习如何为你的造物注入真正的“灵魂”，让它们拥有独特的属性、行为和互动能力。这，是区分工匠与大师的分水岭。

#### 3.1 创生之初：定义“宠物”这一概念 (类与对象)

**故事背景：**

欢迎来到“UESTC魔法宠物店”！你，作为宠物店的首席魔法工程师，接到了第一个激动人心的任务：开发一个虚拟宠物系统。客人们希望能领养到独一无二的宠物，与它们互动、培养感情。你的第一步，就是要定义出“宠物”这个最核心的概念。

**挑战任务：**

1. **灵魂蓝图 (Class) vs. 鲜活个体 (Object)**：
  1. 要创造宠物，你首先需要一张“灵魂蓝图”。在Java魔法中，这就是“类”（Class）。它定义了所有宠物都应具备的共性。请阐述你对“类”的理解。
  2. 有了蓝图，你才能创造出一个个鲜活的“宠物个体”。这就是“对象”（Object）。请阐述你对“对象”的理解。
  3. 如何在这张蓝图上刻画宠物的“内在属性”（如：名字、年龄、饥饿值）和“外在行为”（如：吃饭、玩耍）？
  4. 学习使用“构造仪式”（构造方法），根据蓝图创造出你的第一个宠物实例。
2. **你的第一个造物**：请设计一个具体的宠物蓝图（例如：`MagicCat`、`SpiritDog`或`BabyDragon`），并通过构造仪式实例化它。最后，施展魔法（调用方法），测试它的行为是否符合你的设计。

#### 3.2 灵魂三定律：封装、继承与多态

> 一个稳定的世界，必须有稳定的法则。为了让你创造的宠物灵魂稳固不朽，你需要掌握并运用“灵魂三定律”。

**第一定律：灵魂守护 (封装)**

> 你不希望任何人都能随意篡改你宠物的生命核心数据（比如直接把年龄改成-100岁）。“封装”就是为此而生的守护结界。

1. **构建守护结界**：
  1. 学习并运用Java的“访问控制符”（`public`, `protected`, `private`），为你的宠物蓝图构建起坚固的守护结界。
  2. 深刻阐述为何“封装”是构建一个安全、可控系统的基石。
2. **规范的能量交换**：为你的宠物蓝图中的私有属性，设计公开的“读取”（get）和“修改”（set）方法。当然，你也可以设计更有趣的交互方式，比如`feed(Food food)`来增加饱食度，而不是简单的`setHunger()`。
3. **种族天赋 (静态static)**：
  1. 有些属性和能力是属于整个“种族”的，而非某个体。这就是“静态”魔法。请探究`static`关键字的奥秘，理解静态变量、静态方法和静态代码块。
  2. **挑战**：运用静态变量和构造仪式，为你的每个宠物种族（`MagicCat`类、`SpiritDog`类等）实现一个计数器，统计各种族当前被创造出的个体数量。

**第二定律：血脉传承 (继承)**

> 随着宠物店的发展，你发现猫、狗、龙……它们都有相似之处（名字、年龄、吃饭、睡觉），但又各有不同。一遍遍重复绘制蓝图是低效的。“继承”魔法，让你能轻松地创造出庞大的宠物家族。

1. **绘制生命之树**：
  1. 学习Java的“继承”（`extends`）魔法，理解其核心特性。
  2. 子类如何“觉醒”自己的独特能力（重写父类方法）？
  3. 在子类的构造仪式中，如何借助`super`和`this`关键字，调用父辈的力量？
  4. 什么是“抽象蓝图”（抽象类）？它在构建生命之树时有何妙用？
2. **构建你的宠物家族**：请参考但不限于下面的继承关系图，设计并构建你自己的宠物继承体系。例如，创建一个所有宠物的始祖`Pet`类，然后派生出`Feline`（猫科）、`Canine`（犬科）等，再往下细分。
  1.  **(可在此处插入原有的类继承图)**

**第三定律的补充：契约魔法 (接口)**

> 继承解决了“是什么”的问题（猫是动物），但无法完美解决“能做什么”的问题。比如，“飞行”能力，鸟会，龙也会，但它们并非同一科。“接口”就是一种跨越血脉的“能力契约”。

1. **签订能力契约**：
  1. 学习Java的“接口”（`interface`）魔法，理解其如何定义一种“能力规范”。
  2. 接口与抽象类有何本质区别？
2. **赋予你的宠物超能力**：请自行设计`Flyable`, `Swimmable`, `Healable`等能力接口，并让你的宠物们通过签订契约（实现接口）来获得这些强大的能力。

**第三定律：万物归一 (多态)**

> 这是最高深的灵魂定律。它让你能以统一的方式，号令万千形态各异的宠物，展现出各自独特的行为。所谓“同一道指令，万般不同响应”。

1. **理解多态的无处不在**：
  1. 在Java魔法中，多态体现在方方面面。请至少理解并阐述以下几种场景：父类引用指向子类实例、方法重写、接口引用指向实现类实例。
  2. 当你用一个“始祖”（`Pet`）的眼光看待所有宠物时，如何分辨出它真正的形态？学习`instanceof`关键字的探知魔法。
2. **命运的随机宠物**：请补全下面的代码。当一个新玩家来到你的宠物店时，系统将随机赠送他一只宠物。你需要运用多态和`instanceof`，让他知道自己获得了什么，并展示该宠物的独特叫声。
  1. ```Java
      import java.util.Random;
      
      public class PetStoreOpening {
          public static void main(String[] args) {
              Random random = new Random();
              int choice = random.nextInt(3); // 随机选择 0, 1, 或 2
      
              Pet newCompanion; // 使用你的宠物始祖类
      
              // TODO: 根据随机数choice，为newCompanion实例化一只具体的宠物 (如MagicCat, SpiritDog, BabyDragon)
              switch (choice) {
                  case 0:
                      // newCompanion = new MagicCat(...);
                      break;
                  case 1:
                      // newCompanion = new SpiritDog(...);
                      break;
                  case 2:
                      // newCompanion = new BabyDragon(...);
                      break;
              }
      
              // TODO: 使用instanceof判断newCompanion的真实形态，并向玩家宣布
              // 例如: "恭喜你，获得了一只神奇的魔法猫！"
      
              // TODO: 调用一个被子类重写的方法 (如makeSound())，展现多态的魅力
              // newCompanion.makeSound(); // 魔法猫会“喵~”，灵魂犬会“汪！”，幼龙会“嗷~”
          }
      }
      ```

> 太棒了！你已经掌握了赋予灵魂的核心技术。你的宠物系统初具雏形，老板对你赞不绝口。但要成为真正的魔法架构师，我们还需要学习更高级的构造技巧。

#### 3.3 高级构造技巧：内部类与设计模式

> 简单的灵魂构造已经无法满足日益复杂的需求。现在，你将学习一些高级的、甚至是秘传的魔法构造技巧，它们能让你的系统结构更优雅、更强大、更具扩展性。

**技巧一：灵魂容器 (内部类)**

> 有时，一个灵魂过于复杂，需要将某些紧密相关的辅助灵魂“封装”在内部。这就是“内部类”的艺术。

1. **探索四种容器形态**：了解并阐述成员内部类、静态内部类、局部内部类和匿名内部类的定义、特点及适用场景。
2. **静态内部类应用：优雅的建造者 (Builder模式)**
  1. 仔细阅读并理解下面的“建造者模式”代码。这种链式调用的构造方式，相比传统的构造方法，有何优点？（提示：参数过多、可选参数、不可变对象）
    - ```Java
        public class PetProfile {
            private final String name;
            private final int age;
            private final String favoriteFood;
            private final boolean canFly;
        
            private PetProfile(Builder builder) {
                this.name = builder.name;
                this.age = builder.age;
                this.favoriteFood = builder.favoriteFood;
                this.canFly = builder.canFly;
            }
        
            // ... getters ...
        
            public static class Builder {
                private String name;
                private int age;
                private String favoriteFood = "-未知-"; // 可选参数，提供默认值
                private boolean canFly = false;      // 可选参数，提供默认值
        
                public Builder(String name, int age) { // 核心属性作为构造参数
                    this.name = name;
                    this.age = age;
                }
        
                public Builder favoriteFood(String food) {
                    this.favoriteFood = food;
                    return this;
                }
        
                public Builder canFly(boolean canFly) {
                    this.canFly = canFly;
                    return this;
                }
        
                public PetProfile build() {
                    return new PetProfile(this);
                }
            }
        }
        ```
3. **匿名内部类应用：临时的契约实现**
  1. 在Java 8之后，Lambda表达式让匿名内部类的使用变得更简洁。请了解常见的“函数式接口”（如`Comparator`, `Runnable`）。
  2. **挑战**：对你的宠物列表，分别使用“匿名内部类”、“Lambda表达式”和“方法引用”这三种方式，实现一个`Comparator`，按年龄进行排序。

**技巧二：设计模式的智慧**

> 设计模式，是历代魔法大师们总结出的、应对特定问题的最佳魔法结构。掌握它们，能让你的代码如诗篇般优雅，如城堡般坚固。

1. **单例模式：世界唯一的交互管理器**
  1. 你的宠物店需要一个全局唯一的“交互管理器”（`InteractionManager`）来处理所有宠物之间的互动。如果每个人都能随便创建一个，世界就乱套了。“单例模式”确保了这种唯一性。请了解其概念和至少两种实现方式（如懒汉式、饿汉式）。
  2. **挑战**：为你的宠物系统设计并实现一个单例的`InteractionManager`。
2. **策略模式：可替换的互动行为**
  1. 宠物间的互动方式可能有很多种：友好玩耍、争抢食物、甚至魔法对决。如果都写在`InteractionManager`里，代码会变得臃肿不堪。“策略模式”允许你将这些行为（策略）独立封装，并随时替换。
  2. **挑战**：了解策略模式，并重构你的`InteractionManager`，将具体的交互逻辑（如`play`, `compete`）设计成可替换的策略。
3. **工厂方法模式：专业的宠物孵化器**
  1. 随着宠物种类增多，在代码里用`new MagicCat()`, `new SpiritDog()`会变得混乱且难以管理。“工厂方法模式”能创建一个专业的“宠物孵化器”，将创建过程与使用过程解耦。
  2. **挑战**：了解工厂方法模式，并设计一个`PetFactory`，将你系统中创建各种宠物的逻辑统一管理起来。

> 恭喜你，代码魔法师！你已经完成了“赋予灵魂”的全部试炼。你的宠物们不再是简单的数据，而是拥有了生命、血脉、超能力和复杂互动规则的真正生灵。现在，是时候为这个世界建立永恒的秩序了。准备好迎接下一章的挑战吧！

### 章节四：建立秩序 —— 为你的世界编写永恒的法则

> 魔法师，你的世界已经充满了活生生的、拥有灵魂的宠物。但它们的生命是短暂的，其存在和历史都将随着程序的关闭而消散。一个没有记忆的世界是脆弱的。现在，你将扮演“秩序之神”的角色，使用“数据库”这一终极魔法，为你的世界建立一个永恒的、可追溯的档案系统（Akashic Records），将一切规则与历史固化下来。

#### 4.1 任务零：铸造档案馆与设定守则 (MySQL环境搭建与权限管理)

> 要记录历史，首先需要一个坚不可摧的“档案馆”——MySQL。作为“档案守护者”，你的第一个任务就是亲手铸造它，并设定严格的访问守则。

1. **铸造档案馆**：请在你的魔法工房（本地电脑）中安装MySQL。记录下你的主要安装步骤截图，以及成功通过命令行登录档案馆的瞬间。如果在铸造过程中遇到了任何时空裂缝（错误），请记录你是如何修复它们的（这将是你的加分项）。成功后，尝试使用更便捷的魔法工具（如Navicat）连接并检视你的档案馆。
2. **设定守护者守则**：新生的档案馆只有一个至高无上的`root`管理员，这极不安全。你必须遵循“最小权限原则”，为不同的使用者（用户）分配恰如其分的权限。请在你的档案馆中创建多个新用户，并为他们授予不同等级的访问权限（例如，有的只能读取，有的可以修改特定档案室）。

#### 4.2 任务一：查询阿卡西记录 (SQL基础查询)

> 在遥远的数据星云中，存在一个古老的“阿卡西记录馆”（一个远程数据库），其中封存着另一个世界的历史。作为见习守护者，你需要学习并掌握强大的“SQL咒语”，以从中提取你需要的信息。这将是你管理自己世界档案的基础训练。

**记录馆坐标：**

- **星域地址 (Host)**: `114.132.53.248`
- **访问凭证 (Username)**: `recruit_user` (此凭证仅有读取权限)
- **通行口令 (Password)**: `123456`
- **目标档案库 (Database)**: `recruit_db`

该档案库中存放着五大卷宗：**学生表(students)**, **班级表(classes)**, **教师表(teachers)**, **课程表(courses)**, **成绩表(scores)**。

**你的咒语试炼：**

- **基础咒语练习：**
  - 找出所有姓“张”或姓“李”的学生。
  - 检索所有2003年出生的女性学生。
  - 筛选出成绩在80至90分之间的所有记录。
  - 仅显示学生档案中的前5条姓名和邮箱记录。
  - 查询名字中包含“三”字的学生。
- **复合咒语进阶：**
  - 统计每个班级的学生总数，但只显示人数超过2人的班级。
  - 计算每位学生的平均分，并按降序排列，列出前三名学霸。
  - 查询教授所讲授的所有课程，以及选修这些课程的学生数量。
  - 计算每门课程的平均分、最高分和最低分。
  - 找出所有选修了“数据库原理”或“数据结构”，并且成绩不低于85分的优秀学生信息。

> **守护者提示**：施展这些咒语时可能会遇到困难。不要灰心，这个试炼的目的是让你熟悉SQL中那些强大的关键字。你可以借助AI或查阅魔法书，但必须理解每一句咒语背后的逻辑。

#### 4.3 任务二：优化历史洪流 (数据库性能优化)

> 你的世界日益繁荣，数据如历史洪流般涌入档案馆。很快，你发现某些查询变得异常缓慢，整个世界的“时间流速”似乎都因此变慢了。作为守护者，你必须学会优化你的档案馆，确保历史的记载流畅而高效。

**场景模拟：**

一个庞大的电商帝国的订单系统 `orders` 表，数据量已达数百万条。表结构如下：

```SQL
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    user_id BIGINT,          -- 用户ID
    product_name VARCHAR(255), -- 产品名称
    status VARCHAR(20),      -- 订单状态 (e.g., "待支付", "已支付", "已取消")
    create_time DATETIME     -- 订单创建时间
);
```

最近，一个看似简单的查询变得无法忍受的缓慢：

```SQL
SELECT * FROM orders WHERE status = '已支付';
```

**你的挑战：**

请从“**档案馆结构优化**”（表结构设计）和“**咒语咏唱技巧**”（SQL查询优化）两个方面，提出你的优化建议。如果你还能联想到如何借助外部魔法奇物（如Redis缓存）来与MySQL协同，加速查询，你将获得极高的评价。

## 最终章：世界建成 —— 打造宏伟的“宠物领养中心”

> 见习魔法师，你已经走到了试炼的终点。你掌握了创世的规则，学会了创造生灵、赋予灵魂，并为这一切建立了永恒的秩序。现在，是时候将你所学的一切融会贯通，以一位真正的“世界架构师”的身份，完成你的毕业设计——构建一个功能完备、服务于所有爱心人士的“宠物领养中心”系统。

> 这不仅是一个项目，更是你一手创造的世界与现实世界连接的桥梁。它将帮助那些无家可归的魔法宠物，找到温暖的家。

### 5.1 架构师的工具箱 (前置准备)

> 要建造宏伟的建筑，必先利其器。以下是你需要熟练掌握的现代魔法工程学工具：

- **项目构筑法阵 (Maven)**: 管理和组织你所有魔法构件（依赖）的强大工具。 [学习卷轴](https://maven.org.cn/guides/getting-started/index.html)
- **持久化符文 (Mybatis)**: 将你的Java对象优雅地映射到数据库记录的秘法。 [学习卷轴](https://mybatis.net.cn/)
- **代码简化咒语 (Lombok)**: 让你从繁琐的getter/setter/toString中解放出来的神奇咒语。 [学习卷轴](https://www.cnblogs.com/heyonggang/p/8638374.html)
- **时空回溯之书 (Git)**: 记录你每一次代码变更，让你能穿梭于不同版本之间的神器。 [学习卷轴](https://blog.csdn.net/sereasuesue/article/details/117080435)

#### 5.2 奠定领养中心的基石 (数据库设计)

> 在你的神国（本地数据库）中，开辟一片新的领域，名为 `pet_adoption`。然后，精心设计并建造三座核心神殿（数据表）：

##### **神殿一：Pet (宠物信息档案)**

| 字段名         | 类型     | 长度 | 约束/注释                    |
| -------------- | -------- | ---- | ---------------------------- |
| `id`           | int      |      | 主键, 自动增长               |
| `name`         | varchar  | 50   | 宠物昵称, 不能为空           |
| `species`      | varchar  | 50   | 宠物品种, 不能为空           |
| `age`          | int      |      | 宠物年龄, 不能为空           |
| `adopt_status` | boolean  |      | 领养状态, 默认false (未领养) |
| `added_date`   | datetime |      | 入库时间, 自动设为当前时间   |

##### **神殿二：Adopter (领养人档案)**

| 字段名              | 类型     | 长度 | 约束/注释                  |
| ------------------- | -------- | ---- | -------------------------- |
| `id`                | int      |      | 主键, 自动增长             |
| `name`              | varchar  | 50   | 领养人姓名, 不能为空       |
| `phone`             | varchar  | 20   | 联系电话, 不能为空         |
| `address`           | varchar  | 100  | 家庭住址, 不能为空         |
| `registration_date` | datetime |      | 注册时间, 自动设为当前时间 |
| `password`          | varchar  | 50   | 登录密码, 不能为空         |

##### **神殿三：Adoption_Record (领养契约记录)**

| 字段名          | 类型     | 长度 | 约束/注释                                        |
| --------------- | -------- | ---- | ------------------------------------------------ |
| `id`            | int      |      | 主键, 自动增长                                   |
| `pet_id`        | int      |      | 外键, 关联`pet(id)`, 删除/更新时**restrict**     |
| `adopter_id`    | int      |      | 外键, 关联`adopter(id)`, 删除/更新时**restrict** |
| `adoption_date` | datetime |      | 契约签订时间, 自动设为当前时间                   |
| `status`        | varchar  | 20   | 契约状态 (申请中, 已批准, 已完成)                |

#### 5.3 设置自动化魔法符文 (触发器)

> 为了维护世界的秩序，你需要设置两个强大的自动化符文（触发器），以保证数据的一致性：

1. **`del_pet`** **符文**: 当一只宠物从档案中被删除时，自动清除所有与它相关的领养契约记录。
2. **`del_adopter`** **符文**: 当一位领养人注销档案时，自动清除所有他/她签订的领养契约记录。

#### 5.4 宏伟蓝图 (项目要求)

- **构件管理 (Maven)**: 自行寻找并导入所有必需的Maven坐标，亲身体验依赖管理的乐趣与挑战。
- **代码实现 (Java)**:
  - **数据层 (DAO)**: 实现与数据库交互的接口。
  - **业务层 (Service)**: 编写核心的业务逻辑。
  - **控制层 (Controller)**: 连接用户请求与业务处理。
  - **实体层 (Entity)**: 使用Lombok注解，让你的实体类干净整洁。
  - **核心功能**: 实现完整的CRUD操作和核心的领养流程管理。
  - **健壮性**: 添加必要的输入验证和优雅的异常处理机制。

#### 5.5 领养中心的核心功能

1. **宠物管理**: 添加新宠物、查询与更新信息、变更领养状态。
2. **领养人管理**: 实现领养人的注册与登录，并能管理其个人信息。
3. **领养流程管理**: 提交领养申请、后台审核申请、记录和跟踪整个领养过程的状态。

#### 5.6 传奇挑战 (加分项)

> 做到这里的你已经是一位杰出的架构师了！但如果你渴望成为传奇，不妨挑战以下任务：

- **高级符文**: 熟练运用Mybatis完成所有数据库操作。
- **日志之眼**: 添加必要的日志记录，让系统的每一个行为都有迹可循。
- **坚固壁垒**: 实现更完善的输入验证和异常处理。

> **最终试炼的起点**：请从以下时空坐标下载项目的基础框架，开始你的建造之旅！https://github.com/sypdmn/YOLO-backend

### 旅程的终点，亦是新的起点

恭喜你，伟大的代码魔法师！

你已经完成了从“入门”到“建成”的全部试炼。你亲手构建的“宠物数字世界”已经熠熠生辉。这趟旅程不仅检验了你的Java魔法技艺，更展现了你作为一名创造者的无限潜力。

请将你完整的“世界蓝图”（项目代码）和这份“冒险日志”（答题文档）一并提交。我们期待在YOLO工作室的更高舞台上，与你共同创造更广阔的数字星辰！